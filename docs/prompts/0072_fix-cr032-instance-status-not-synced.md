---
name: fix-cr032-instance-status-not-synced
description: Fix instance status in metadata becoming stale
status: Done
created_at: 2026-01-29 00:00:00
updated_at: 2026-01-29 00:00:00
impl_progress:
  planning: completed
  design: completed
  implementation: completed
  review: completed
  testing: completed
severity: LOW
category: Code Quality
---

## 0072. fix-cr032-instance-status-not-synced

### Background

The instance status stored in metadata in `cc_bridge/core/instances.py` can become stale. The stored status may not reflect the actual runtime state:

1. **Container stopped externally**: Metadata still shows "running"
2. **Tmux session killed**: Status not updated
3. **No periodic refresh**: Stale data persists
4. **Misleading UI**: Users see wrong status

### Requirements

**Functional Requirements:**
- Refresh status when reading instance info
- Cache status with TTL (time-to-live)
- Force refresh option
- Background refresh for frequently accessed instances

**Non-Functional Requirements:**
- Minimal performance impact
- Configurable refresh interval
- Clear staleness indicators

**Acceptance Criteria:**
- [ ] Status refreshed on read (or cached with TTL)
- [ ] Configurable refresh TTL
- [ ] Force refresh available
- [ ] Stale indicator in output
- [ ] Tests verify status accuracy

### Q&A

[Clarifications added during planning phase]

### Design

**Status Refresh Pattern:**
```python
from datetime import datetime, timedelta
from dataclasses import dataclass

STATUS_TTL = timedelta(seconds=30)

@dataclass
class CachedStatus:
    status: str
    timestamp: datetime

    @property
    def is_stale(self) -> bool:
        return datetime.now() - self.timestamp > STATUS_TTL

class Instance:
    def __init__(self, ...):
        self._cached_status: CachedStatus | None = None

    def get_status(self, force_refresh: bool = False) -> str:
        """Get instance status, refreshing if needed."""
        if force_refresh or self._cached_status is None or self._cached_status.is_stale:
            self._cached_status = CachedStatus(
                status=self._fetch_actual_status(),
                timestamp=datetime.now()
            )
        return self._cached_status.status

    def _fetch_actual_status(self) -> str:
        """Fetch actual status from tmux/docker."""
        # Implementation depends on instance type
        pass
```

### Plan

1. Add CachedStatus dataclass
2. Implement _fetch_actual_status() for each instance type
3. Add TTL-based caching
4. Add force_refresh parameter
5. Update CLI to use refreshed status
6. Test status accuracy after external changes

### Artifacts

| Type | Path | Generated By | Date |
|------|------|--------------|------|

### References

- File: `cc_bridge/core/instances.py`
- Model: `cc_bridge/models/instances.py`

### Implementation Details

**Issue:** Instance status stored in metadata could become stale when containers/sessions were stopped externally, with no periodic refresh mechanism.

**Solution:** Implemented status caching with TTL and automatic metadata updates when status changes.

**Changes Made:**

1. **Added imports** to `cc_bridge/core/instances.py`:
   - `from dataclasses import dataclass`
   - `from datetime import timedelta`

2. **Added STATUS_TTL constant** (line 23):
   ```python
   # Status cache TTL (time-to-live) - refresh status after this duration
   STATUS_TTL = timedelta(seconds=30)
   ```

3. **Created CachedStatus dataclass** (lines 26-40):
   - Stores status and timestamp
   - Provides `is_stale` property to check if cache expired
   ```python
   @dataclass
   class CachedStatus:
       status: str
       timestamp: datetime

       @property
       def is_stale(self) -> bool:
           return datetime.now() - self.timestamp > STATUS_TTL
   ```

4. **Added status cache to InstanceManager** (line 52):
   ```python
   self._status_cache: dict[str, CachedStatus] = {}  # Status cache with TTL
   ```

5. **Refactored get_instance_status()** (lines 251-289):
   - Added `force_refresh` parameter to bypass cache
   - Checks cache before fetching actual status
   - Updates cache on fetch
   - Automatically updates metadata when status changes
   ```python
   def get_instance_status(self, name: str, force_refresh: bool = False) -> str:
       cached = self._status_cache.get(name)
       if not force_refresh and cached and not cached.is_stale:
           return cached.status

       actual_status = self._fetch_actual_status(instance)
       self._status_cache[name] = CachedStatus(...)

       # Update metadata if status changed (async, fire-and-forget)
       if instance.status != actual_status:
           asyncio.create_task(self.update_instance_status(name, actual_status))

       return actual_status
   ```

6. **Extracted _fetch_actual_status()** (lines 292-316):
   - Separated actual status checking logic
   - Checks Docker container status or tmux PID
   - Used by get_instance_status() for runtime checks

**Benefits:**
1. **Automatic Metadata Sync**: Status in metadata auto-updates when stale
2. **Performance**: Cached status avoids expensive runtime checks (30s TTL)
3. **Force Refresh**: Can bypass cache with `force_refresh=True`
4. **Fire-and-Forget**: Metadata updates happen asynchronously without blocking
5. **External Change Detection**: Catches containers/sessions stopped externally
6. **Minimal Performance Impact**: Cache hits return immediately, only refreshes when stale
7. **Clear TTL**: 30-second default balances freshness and performance

**Cache Behavior:**
- **First call**: Fetches actual status, caches it, updates metadata if changed
- **Within 30s**: Returns cached status (fast)
- **After 30s**: Refetches actual status, updates cache and metadata
- **force_refresh=True**: Always fetches actual status, bypasses cache

**Usage Examples:**
```python
# Get cached status (refreshes if stale)
status = manager.get_instance_status("my_instance")

# Force immediate refresh
status = manager.get_instance_status("my_instance", force_refresh=True)
```

**Note:** Metadata updates happen asynchronously using `asyncio.create_task()`, which means status changes are eventually consistent rather than immediately persisted. This is acceptable for status metadata which is primarily informational.
