---
name: fix-cr033-no-retry-logic-transient-failures
description: Add retry mechanism for transient Telegram API failures
status: Done
created_at: 2026-01-29 00:00:00
updated_at: 2026-01-29 00:00:00
impl_progress:
  planning: completed
  design: completed
  implementation: completed
  review: completed
  testing: completed
severity: LOW
category: Code Quality
---

## 0073. fix-cr033-no-retry-logic-transient-failures

### Background

The `TelegramClient` in `cc_bridge/core/telegram.py` has no retry mechanism for API failures. Transient failures (network blips, rate limits, server errors) cause immediate failure instead of retrying:

1. **Network issues**: Temporary connectivity problems fail immediately
2. **Rate limits**: 429 responses not handled with backoff
3. **Server errors**: 5xx responses could succeed on retry
4. **Poor reliability**: Single failures break operations

### Requirements

**Functional Requirements:**
- Implement retry with exponential backoff
- Handle rate limit responses (429)
- Retry on 5xx server errors
- Configurable retry count and backoff

**Non-Functional Requirements:**
- Maximum total retry time
- Clear logging of retry attempts
- Don't retry non-recoverable errors (4xx except 429)

**Acceptance Criteria:**
- [ ] Retry logic for transient errors
- [ ] Exponential backoff between retries
- [ ] Rate limit (429) handled with Retry-After header
- [ ] Configurable max retries
- [ ] Tests verify retry behavior
- [ ] Clear retry logging

### Q&A

[Clarifications added during planning phase]

### Design

**Retry Pattern:**
```python
from tenacity import (
    retry,
    stop_after_attempt,
    wait_exponential,
    retry_if_exception_type
)
import httpx

class TelegramClient:
    MAX_RETRIES = 3
    BASE_BACKOFF = 1  # seconds
    MAX_BACKOFF = 30  # seconds

    @retry(
        stop=stop_after_attempt(MAX_RETRIES),
        wait=wait_exponential(multiplier=BASE_BACKOFF, max=MAX_BACKOFF),
        retry=retry_if_exception_type((
            httpx.TimeoutException,
            httpx.NetworkError,
        )),
        before_sleep=lambda retry_state: logger.info(
            f"Retrying after {retry_state.outcome.exception()}, "
            f"attempt {retry_state.attempt_number}"
        )
    )
    async def send_message(self, ...):
        response = await self._client.post(...)

        # Handle rate limit specifically
        if response.status_code == 429:
            retry_after = int(response.headers.get("Retry-After", 5))
            await asyncio.sleep(retry_after)
            raise RateLimitError("Rate limited, retrying")

        # Retry on server errors
        if response.status_code >= 500:
            raise ServerError(f"Server error: {response.status_code}")

        return response
```

**Without tenacity:**
```python
async def with_retry(
    func,
    max_retries: int = 3,
    base_delay: float = 1.0
):
    for attempt in range(max_retries + 1):
        try:
            return await func()
        except (httpx.TimeoutException, httpx.NetworkError) as e:
            if attempt == max_retries:
                raise
            delay = base_delay * (2 ** attempt)
            logger.info(f"Retry {attempt + 1}/{max_retries} after {delay}s: {e}")
            await asyncio.sleep(delay)
```

### Plan

1. Add tenacity or implement custom retry logic
2. Define retryable exception types
3. Add retry decorator to API methods
4. Handle 429 with Retry-After header
5. Handle 5xx with exponential backoff
6. Add retry attempt logging
7. Test retry scenarios

### Artifacts

| Type | Path | Generated By | Date |
|------|------|--------------|------|

### References

- File: `cc_bridge/core/telegram.py`
- httpx: https://www.python-httpx.org/
- Telegram Bot API: https://core.telegram.org/bots/api

### Implementation Details

**Issue:** TelegramClient had no retry mechanism for transient failures (network issues, rate limits, server errors), causing immediate failure on temporary problems.

**Solution:** Implemented custom retry logic with exponential backoff for all API methods, avoiding the need for external dependencies like tenacity.

**Changes Made:**

1. **Added retry constants** (lines 31-34):
   ```python
   # Retry settings for transient failures
   MAX_RETRIES = 3
   BASE_BACKOFF = 1.0  # Base backoff in seconds
   MAX_BACKOFF = 30.0  # Maximum backoff in seconds
   ```

2. **Implemented _retry_with_backoff() helper** (lines 37-136):
   - Custom async retry function with exponential backoff
   - Retries on `httpx.TimeoutException` (network timeouts)
   - Retries on `httpx.NetworkError` (connection errors)
   - Retries on 5xx server errors
   - Handles 429 rate limit with Retry-After header
   - Does NOT retry on 4xx errors (except 429)
   - Logs each retry attempt with delay information
   ```python
   async def _retry_with_backoff(func, max_retries=3, base_backoff=1.0, max_backoff=30.0):
       for attempt in range(max_retries + 1):
           try:
               return await func()
           except httpx.TimeoutException as e:
               delay = min(base_backoff * (2**attempt), max_backoff)
               logger.warning("Telegram API timeout, retrying", ...)
               await asyncio.sleep(delay)
           except httpx.NetworkError as e:
               # Similar handling
           except httpx.HTTPStatusError as e:
               if e.response.status_code == 429:
                   # Use Retry-After header
               elif e.response.status_code >= 500:
                   # Retry with exponential backoff
               else:
                   # Don't retry (4xx except 429)
                   raise
   ```

3. **Updated all API methods to use retry**:
   - `send_message()` (lines 153-187)
   - `set_webhook()` (lines 189-218)
   - `get_webhook_info()` (lines 220-246)
   - `delete_webhook()` (lines 248-274)
   - `get_updates()` (lines 276-307)
   - `answer_callback_query()` (lines 309-340)

   **Pattern:**
   ```python
   async def api_method(self, ...):
       async def _do_request():
           client = await self._get_client()
           response = await client.post/get(...)
           response.raise_for_status()  # Raises HTTPStatusError for 4xx/5xx
           return response.json()

       return await _retry_with_backoff(_do_request)
   ```

**Benefits:**
1. **Resilience**: Handles transient network failures automatically
2. **Rate Limit Handling**: Respects Telegram's Retry-After header for 429 responses
3. **Server Error Recovery**: Retries on 5xx errors that might succeed on retry
4. **Exponential Backoff**: 1s, 2s, 4s, 8s... up to 30s max between retries
5. **Clear Logging**: Each retry logged with attempt number and delay
6. **No New Dependencies**: Custom implementation avoids adding tenacity
7. **Configurable**: Easy to adjust MAX_RETRIES, BASE_BACKOFF, MAX_BACKOFF
8. **Smart Retry**: Only retries recoverable errors, fails fast on permanent errors

**Retry Behavior:**
- **TimeoutException**: Retry with exponential backoff (1s, 2s, 4s, 8s...)
- **NetworkError**: Retry with exponential backoff
- **429 Rate Limit**: Use Retry-After header (respects Telegram's guidance)
- **5xx Server Errors**: Retry with exponential backoff
- **4xx Client Errors**: No retry (permanent errors, won't succeed on retry)

**Backoff Schedule:**
- Attempt 1: Immediate
- Attempt 2: 1s delay
- Attempt 3: 2s delay
- Attempt 4: 4s delay
- Max delay capped at 30s

**Total Max Duration:** ~37 seconds (1+2+4+8+16+30) for worst-case scenario.
