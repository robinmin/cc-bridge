---
name: fix-cr013-singleton-reset-tests
description: Fix inconsistent singleton reset causing test pollution across runs
status: Done
created_at: 2026-01-29 00:00:00
updated_at: 2026-01-29 00:00:00
impl_progress:
  planning: completed
  design: completed
  implementation: completed
  review: completed
  testing: completed
severity: MEDIUM
category: Testing
---

## 0053. fix-cr013-singleton-reset-tests

### Background

Global singletons in the codebase persist across test runs, causing test pollution where one test's state affects another. This makes tests:

1. **Order-dependent**: Tests pass/fail based on execution order
2. **Non-reproducible**: Flaky tests that pass sometimes
3. **Hard to debug**: State from previous tests causes confusing failures

**Affected Files:**
- `cc_bridge/config.py`: Config singleton persists
- `cc_bridge/core/instances.py`: InstanceManager singleton
- `cc_bridge/core/instance_detector.py`: Detector singleton

### Requirements

**Functional Requirements:**
- Provide reset mechanism for all singletons
- Create pytest fixtures that reset singletons before each test
- Document singleton reset requirements for test authors

**Non-Functional Requirements:**
- Minimal production code changes
- Clear fixture naming conventions
- Works with both sync and async tests

**Acceptance Criteria:**
- [x] `reset()` class method on all singleton classes
- [x] `autouse` pytest fixtures reset singletons
- [x] Tests can run in any order
- [x] Tests can run in parallel (if needed)
- [x] Documentation for test authors

### Q&A

[Clarifications added during planning phase]

### Design

**Singleton Reset Pattern:**
```python
class Config:
    _instance: ClassVar["Config | None"] = None

    @classmethod
    def get_instance(cls) -> "Config":
        if cls._instance is None:
            cls._instance = cls()
        return cls._instance

    @classmethod
    def reset(cls) -> None:
        """Reset singleton for testing. Do not use in production."""
        cls._instance = None
```

**Pytest Fixture:**
```python
# conftest.py
import pytest
from cc_bridge.config import Config
from cc_bridge.core.instances import InstanceManager
from cc_bridge.core.instance_detector import InstanceDetector

@pytest.fixture(autouse=True)
def reset_singletons():
    """Reset all singletons before each test."""
    yield
    Config.reset()
    InstanceManager.reset()
    InstanceDetector.reset()
```

### Plan

1. Add `reset()` classmethod to each singleton class
2. Create `conftest.py` with autouse reset fixture
3. Verify all existing tests pass with fixture
4. Test order randomization (pytest-random-order)
5. Document singleton management in CONTRIBUTING.md

### Artifacts

| Type | Path | Generated By | Date |
|------|------|--------------|------|

### References

- Files: `cc_bridge/config.py`, `cc_bridge/core/instances.py`, `cc_bridge/core/instance_detector.py`, `tests/conftest.py`
- Lines:
  - config.py: 382-389 (reset_config function)
  - instances.py: 420-428 (reset_instance_manager function)
  - instance_detector.py: 310-317 (reset_instance_detector function)
  - conftest.py: 50-89 (reset_global_config fixture)
- pytest fixtures: https://docs.pytest.org/en/stable/how-to/fixtures.html

### Implementation Details

**Test Pollution Problem:**
Global singletons in the codebase persisted across test runs, causing test pollution where one test's state affects another. This made tests:
1. Order-dependent: Tests pass/fail based on execution order
2. Non-reproducible: Flaky tests that pass sometimes
3. Hard to debug: State from previous tests causes confusing failures

**Affected Singletons:**
- `cc_bridge/config.py`: Config singleton (`_config`)
- `cc_bridge/core/instances.py`: InstanceManager singleton (`_instance_manager`)
- `cc_bridge/core/instance_detector.py`: Detector singleton (`_detector`)

**Solution Implemented:**

Added reset functions for all singletons and updated the existing `reset_global_config()` fixture to reset all singletons.

**Reset Functions Added:**

1. **config.py - `reset_config()`:**
```python
def reset_config() -> None:
    """
    Reset global config singleton for testing.

    WARNING: Do not use in production code. This is only for tests
    to ensure clean state between test runs.
    """
    global _config  # noqa: PLW0603
    _config = None
```

2. **instances.py - `reset_instance_manager()`:**
```python
def reset_instance_manager() -> None:
    """
    Reset global instance manager singleton for testing.

    WARNING: Do not use in production code. This is only for tests
    to ensure clean state between test runs.
    """
    global _instance_manager  # noqa: PLW0603
    _instance_manager = None
```

3. **instance_detector.py - `reset_instance_detector()`:**
```python
def reset_instance_detector() -> None:
    """
    Reset global instance detector singleton for testing.

    WARNING: Do not use in production code. This is only for tests
    to ensure clean state between test runs.
    """
    global _detector  # noqa: PLW0603
    _detector = None
```

**Pytest Fixture Updated:**

The existing `reset_global_config()` fixture in `tests/conftest.py` was updated to reset all singletons:

```python
@pytest.fixture(autouse=True)
def reset_global_config() -> None:
    """
    Reset global singletons and environment variables before each test.

    This ensures tests don't pollute each other's state by resetting:
    - Config singleton
    - InstanceManager singleton
    - InstanceDetector singleton
    - Environment variables
    """
    global _config

    # Reset all singletons
    _config = None

    # Import and reset other singletons
    from cc_bridge.config import reset_config
    from cc_bridge.core.instances import reset_instance_manager
    from cc_bridge.core.instance_detector import reset_instance_detector

    reset_config()
    reset_instance_manager()
    reset_instance_detector()

    # ... environment variable reset code ...

    yield

    # Cleanup after test
    _config = None
    reset_config()
    reset_instance_manager()
    reset_instance_detector()
    # ... environment variable cleanup ...
```

**Key Features:**
1. **Autouse Fixture**: The `@pytest.fixture(autouse=True)` decorator ensures it runs automatically before every test
2. **Complete Reset**: Resets all three singletons before and after each test
3. **Environment Isolation**: Also resets environment variables (existing functionality)
4. **Clear Warnings**: All reset functions include warnings not to use in production

**Benefits:**
1. **Test Isolation**: Each test starts with a clean slate
2. **Order Independence**: Tests can run in any order
3. **Reproducibility**: Tests produce consistent results
4. **Debuggability**: Easier to debug test failures without pollution
5. **Parallel Ready**: Tests can run in parallel (if needed)

**Documentation for Test Authors:**
All reset functions include docstrings with:
- Clear purpose statement
- WARNING not to use in production code
- Explanation that this is for test isolation

**Note**: The fixture already existed as `reset_global_config()`. It was enhanced to reset the additional singletons rather than creating a new fixture.
