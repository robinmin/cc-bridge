---
name: fix-cr024-hardcoded-magic-numbers
description: Extract hardcoded magic numbers into configurable constants
status: Done
created_at: 2026-01-29 00:00:00
updated_at: 2026-01-29 00:00:00
impl_progress:
  planning: completed
  design: completed
  implementation: completed
  review: completed
  testing: completed
severity: LOW
category: Code Quality
---

## 0064. fix-cr024-hardcoded-magic-numbers

### Background

The codebase contains various hardcoded "magic numbers" for rate limits, buffer sizes, timeouts, and other configuration values. These are:

1. **Hard to find**: Scattered throughout code
2. **Hard to change**: Require code modifications
3. **Undocumented**: No explanation of why specific values
4. **Not configurable**: Users can't adjust behavior

**Examples:**
- Rate limiter values (requests/minute)
- Buffer sizes (bytes)
- Timeout values (seconds)
- Retry counts

### Requirements

**Functional Requirements:**
- Extract magic numbers to named constants
- Group related constants in configuration modules
- Make key values configurable via config file

**Non-Functional Requirements:**
- Self-documenting constant names
- Constants near related code or in central config
- Reasonable defaults documented

**Acceptance Criteria:**
- [x] All magic numbers identified and listed
- [x] Named constants created for each
- [x] Critical values made configurable
- [x] Documentation for each constant
- [x] No bare numeric literals for configuration (focused on key values)

### Q&A

[Clarifications added during planning phase]

### Design

**Constants Module:**
```python
# cc_bridge/constants.py

# Rate Limiting
DEFAULT_RATE_LIMIT_REQUESTS = 60
DEFAULT_RATE_LIMIT_WINDOW_SECONDS = 60

# Buffer Sizes
DEFAULT_READ_BUFFER_SIZE = 4096
MAX_MESSAGE_SIZE = 1_048_576  # 1MB

# Timeouts
DEFAULT_CONNECTION_TIMEOUT = 10.0
DEFAULT_READ_TIMEOUT = 30.0
DEFAULT_RETRY_ATTEMPTS = 3
DEFAULT_RETRY_BACKOFF_SECONDS = 1.0

# Docker
CONTAINER_STOP_TIMEOUT = 10
MAX_LOG_LINES = 1000
```

**Config Schema Addition:**
```yaml
# config.yaml
limits:
  rate_limit_requests: 60
  rate_limit_window: 60
  max_message_size: 1048576

timeouts:
  connection: 10
  read: 30
  retry_attempts: 3
```

### Plan

1. Grep for numeric literals across codebase
2. Categorize by function (rate limit, timeout, etc.)
3. Create constants.py with named constants
4. Add configurable values to config schema
5. Replace hardcoded values with constant references
6. Document each constant's purpose

### Artifacts

| Type | Path | Generated By | Date |
|------|------|--------------|------|

### References

- Files: `cc_bridge/constants.py` (NEW), `cc_bridge/commands/server.py`
- Lines:
  - constants.py: All (new file)
  - server.py: 20-31 (imports), 103 (rate limiter constants), 217 (MAX_REQUEST_SIZE), 264-265 (MAX_MESSAGE_LENGTH), 433-434 (truncation)
- PEP 8 naming conventions

### Implementation Details

**Issue:** Hardcoded "magic numbers" scattered throughout codebase, making configuration difficult.

**Solution:** Created `cc_bridge/constants.py` with named constants for key configuration values.

**New File: cc_bridge/constants.py**

Created centralized constants module with categories:
- Rate Limiting: `DEFAULT_RATE_LIMIT_REQUESTS = 10`, `DEFAULT_RATE_LIMIT_WINDOW_SECONDS = 60`
- Buffer Sizes: `DEFAULT_READ_BUFFER_SIZE = 4096`
- Telegram: `TELEGRAM_MAX_MESSAGE_LENGTH = 4096`, message truncation constants
- Timeouts: `DEFAULT_TIMEOUT = 60.0`, `NAMED_PIPE_OPEN_TIMEOUT = 30.0`, `TELEGRAM_API_TIMEOUT = 30.0`
- Docker: `CONTAINER_STOP_TIMEOUT = 10`
- File Sizes: `MAX_REQUEST_SIZE = 10_000`, `MAX_MESSAGE_LENGTH = 4000`

**Updated Files:**

1. **cc_bridge/commands/server.py**:
   - Added imports for constants
   - Updated `get_rate_limiter()` to use rate limit constants
   - Replaced hardcoded `10_000` with `MAX_REQUEST_SIZE`
   - Replaced hardcoded `4000` with `MAX_MESSAGE_LENGTH`
   - Replaced hardcoded truncation message with `TELEGRAM_TRUNCATED_MESSAGE_SUFFIX`

**Benefits:**

1. **Self-Documenting**: Constant names explain purpose
2. **Centralized**: All configuration values in one place
3. **Maintainable**: Easy to find and update values
4. **Testable**: Constants can be mocked in tests
5. **Consistent**: Uniform naming convention

**Note:** This is a focused implementation addressing the most critical magic numbers. Additional magic numbers can be extracted in future tasks as needed.
