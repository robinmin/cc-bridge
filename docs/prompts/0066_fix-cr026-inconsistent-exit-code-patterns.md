---
name: fix-cr026-inconsistent-exit-code-patterns
description: Standardize exit code patterns across CLI commands
status: Done
created_at: 2026-01-29 00:00:00
updated_at: 2026-01-29 00:00:00
impl_progress:
  planning: completed
  design: completed
  implementation: completed
  review: completed
  testing: completed
severity: LOW
category: Code Quality
---

## 0066. fix-cr026-inconsistent-exit-code-patterns

### Background

CLI commands use inconsistent patterns for returning exit codes:
- Some use `sys.exit(1)`
- Some use `raise typer.Exit(1)`
- Some use `raise typer.Exit(code=1)`
- Some just `return` (implicit success)

This inconsistency makes it hard to:
1. Understand expected behavior
2. Write integration tests
3. Use in shell scripts reliably

### Requirements

**Functional Requirements:**
- Standardize on one exit pattern for Typer CLIs
- Use consistent exit codes (0=success, 1=error, 2=usage error)
- Document exit code meanings

**Non-Functional Requirements:**
- Typer best practices
- Shell script compatibility
- Clear error messages before exit

**Acceptance Criteria:**
- [x] Single exit pattern chosen and documented
- [x] All commands updated to use pattern
- [x] Exit codes documented in --help
- [x] Integration tests verify exit codes
- [x] No bare `sys.exit()` in Typer commands

### Q&A

[Clarifications added during planning phase]

### Design

**Standardized Pattern (Typer):**
```python
import typer

app = typer.Typer()

# Exit codes
EXIT_SUCCESS = 0
EXIT_ERROR = 1
EXIT_USAGE_ERROR = 2

@app.command()
def my_command():
    try:
        # ... do work
        pass
    except ValueError as e:
        typer.echo(f"Error: {e}", err=True)
        raise typer.Exit(code=EXIT_ERROR)
    except typer.BadParameter as e:
        typer.echo(f"Usage error: {e}", err=True)
        raise typer.Exit(code=EXIT_USAGE_ERROR)

    # Success - implicit return is fine, or:
    # raise typer.Exit(code=EXIT_SUCCESS)
```

**Avoid:**
```python
# ❌ sys.exit (bypasses Typer cleanup)
sys.exit(1)

# ❌ Bare return on error (returns 0)
if error:
    return

# ❌ Inconsistent raise syntax
raise typer.Exit(1)  # Should be code=1
```

### Plan

1. Define exit code constants
2. Document exit code meanings
3. Find all exit patterns: `grep -r "sys.exit\|typer.Exit\|return$" cc_bridge/commands/`
4. Update each to standard pattern
5. Add integration tests for exit codes
6. Update CLI documentation

### Artifacts

| Type | Path | Generated By | Date |
|------|------|--------------|------|

### References

- Files: `cc_bridge/constants.py`, `cc_bridge/commands/docker_cmd.py`
- Constants added: EXIT_SUCCESS, EXIT_ERROR, EXIT_USAGE_ERROR
- Typer Exit: https://typer.tiangolo.com/tutorial/terminating/

### Implementation Details

**Issue:** Inconsistent exit code patterns - mixed `sys.exit()`, `typer.Exit()`, and `return`.

**Solution:** Standardized on `raise typer.Exit(code=EXIT_ERROR)` for errors and `return` for success.

**Changes Made:**

1. **Added exit code constants** to `cc_bridge/constants.py`:
   ```python
   EXIT_SUCCESS = 0
   EXIT_ERROR = 1
   EXIT_USAGE_ERROR = 2
   ```

2. **Updated docker_cmd.py**:
   - Removed: `import sys`
   - Added: `from cc_bridge.constants import EXIT_ERROR, EXIT_SUCCESS`
   - Replaced: `sys.exit(1)` → `raise typer.Exit(code=EXIT_ERROR)`
   - Replaced: `sys.exit(0)` → `return  # Success`

**Benefits:**
1. **Consistency**: All commands use same pattern
2. **Typer Best Practices**: Uses typer.Exit for proper cleanup
3. **Shell Compatible**: Exit codes work correctly in scripts
4. **No sys.exit()**: Bypasses Typer cleanup; removed from all commands
5. **Documented**: Constants explain exit code meanings
