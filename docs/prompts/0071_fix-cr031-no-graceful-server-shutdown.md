---
name: fix-cr031-no-graceful-server-shutdown
description: Implement graceful shutdown handling for pending requests
status: Done
created_at: 2026-01-29 00:00:00
updated_at: 2026-01-29 00:00:00
impl_progress:
  planning: completed
  design: completed
  implementation: completed
  review: completed
  testing: completed
severity: LOW
category: Code Quality
---

## 0071. fix-cr031-no-graceful-server-shutdown

### Background

The lifespan context manager in `cc_bridge/commands/server.py` doesn't handle pending requests during shutdown. When the server receives SIGTERM/SIGINT:

1. **Abrupt termination**: In-flight requests are dropped
2. **Lost work**: Partial operations may leave inconsistent state
3. **Poor UX**: Clients see connection errors
4. **Resource leaks**: Connections not properly closed

### Requirements

**Functional Requirements:**
- Wait for pending requests to complete (with timeout)
- Stop accepting new requests during shutdown
- Graceful connection draining
- Configurable shutdown timeout

**Non-Functional Requirements:**
- Signal handler for SIGTERM/SIGINT
- Clear shutdown logging
- Maximum shutdown time enforced

**Acceptance Criteria:**
- [ ] Pending requests complete during shutdown
- [ ] New requests rejected after shutdown signal
- [ ] Configurable shutdown timeout
- [ ] Clear shutdown progress logging
- [ ] Force shutdown after timeout
- [ ] Tests verify graceful shutdown

### Q&A

[Clarifications added during planning phase]

### Design

**Graceful Shutdown Pattern:**
```python
import asyncio
import signal
from contextlib import asynccontextmanager

SHUTDOWN_TIMEOUT = 30  # seconds

class GracefulShutdown:
    def __init__(self):
        self._shutdown_event = asyncio.Event()
        self._pending_requests = 0
        self._lock = asyncio.Lock()

    async def wait_for_shutdown(self, timeout: float = SHUTDOWN_TIMEOUT):
        """Wait for pending requests to complete."""
        try:
            await asyncio.wait_for(
                self._wait_for_pending(),
                timeout=timeout
            )
        except asyncio.TimeoutError:
            logger.warning(
                f"Shutdown timeout after {timeout}s, "
                f"{self._pending_requests} requests still pending"
            )

    async def _wait_for_pending(self):
        while self._pending_requests > 0:
            await asyncio.sleep(0.1)

@asynccontextmanager
async def lifespan(app: FastAPI):
    shutdown_handler = GracefulShutdown()

    # Setup signal handlers
    loop = asyncio.get_running_loop()
    for sig in (signal.SIGTERM, signal.SIGINT):
        loop.add_signal_handler(
            sig,
            lambda: asyncio.create_task(shutdown_handler.initiate_shutdown())
        )

    yield

    # Graceful shutdown
    logger.info("Initiating graceful shutdown...")
    await shutdown_handler.wait_for_shutdown()
    logger.info("Shutdown complete")
```

### Plan

1. Create GracefulShutdown helper class
2. Track pending request count
3. Add signal handlers for SIGTERM/SIGINT
4. Wait for pending requests with timeout
5. Add shutdown progress logging
6. Test with concurrent requests during shutdown

### Artifacts

| Type | Path | Generated By | Date |
|------|------|--------------|------|

### References

- File: `cc_bridge/commands/server.py`
- File: `cc_bridge/constants.py`
- FastAPI lifespan: https://fastapi.tiangolo.com/advanced/events/
- Signal handling: https://docs.python.org/3/library/signal.html

### Implementation Details

**Issue:** The lifespan context manager didn't handle pending requests during shutdown, causing abrupt termination of in-flight requests.

**Solution:** Implemented graceful shutdown with request tracking, signal handlers, and configurable timeout.

**Changes Made:**

1. **Added SERVER_SHUTDOWN_TIMEOUT constant** to `cc_bridge/constants.py`:
   ```python
   # Server Shutdown
   SERVER_SHUTDOWN_TIMEOUT = 30  # Maximum seconds to wait for graceful shutdown
   ```

2. **Created GracefulShutdown class** in `cc_bridge/commands/server.py` (lines 38-118):
   - Tracks pending request count with thread-safe locking
   - Provides `increment_requests()` and `decrement_requests()` methods
   - Implements `wait_for_shutdown()` with progress logging and timeout enforcement
   - Provides `is_shutting_down()` status check
   ```python
   class GracefulShutdown:
       def __init__(self, timeout: float = SERVER_SHUTDOWN_TIMEOUT):
           self._shutdown_event = asyncio.Event()
           self._pending_requests = 0
           self._lock = asyncio.Lock()
           self._timeout = timeout
   ```

3. **Updated lifespan context manager** (lines 152-182):
   - Sets up signal handlers for SIGTERM/SIGINT using `asyncio.get_running_loop()`
   - Calls `wait_for_shutdown()` during shutdown phase
   - Logs shutdown progress with timeout information
   ```python
   @asynccontextmanager
   async def lifespan(app: FastAPI):
       shutdown_handler = get_shutdown_handler()
       loop = asyncio.get_running_loop()

       def handle_shutdown_signal():
           if not shutdown_handler.is_shutting_down():
               logger.info("Shutdown signal received")
               shutdown_handler._shutdown_event.set()

       for sig in (signal.SIGTERM, signal.SIGINT):
           loop.add_signal_handler(sig, handle_shutdown_signal)

       yield

       logger.info("Initiating graceful shutdown...")
       await shutdown_handler.wait_for_shutdown()
   ```

4. **Added request tracking middleware** (lines 189-213):
   - Rejects new requests with 503 during shutdown
   - Increments pending count before processing
   - Decrements count in finally block (even on errors)
   ```python
   @app.middleware("http")
   async def track_requests(request: Request, call_next):
       shutdown_handler = get_shutdown_handler()

       if shutdown_handler.is_shutting_down():
           return JSONResponse(status_code=503, ...)

       await shutdown_handler.increment_requests()
       try:
           response = await call_next(request)
           return response
       finally:
           await shutdown_handler.decrement_requests()
   ```

5. **Added imports** to server.py:
   - `import asyncio`
   - `import signal`
   - `SERVER_SHUTDOWN_TIMEOUT` from constants

**Benefits:**
1. **Graceful Shutdown**: Waits for pending requests to complete (with timeout)
2. **No Lost Work**: In-flight requests can finish before termination
3. **Better UX**: Clients see 503 instead of connection errors during shutdown
4. **Clear Logging**: Progress logged every 5 seconds during shutdown
5. **Signal Handling**: Responds to SIGTERM/SIGINT for proper deployment shutdowns
6. **Configurable Timeout**: 30-second timeout prevents hanging forever
7. **Force Shutdown**: After timeout, server terminates even with pending requests

**Shutdown Flow:**
1. Signal received (SIGTERM/SIGINT)
2. New requests return 503 immediately
3. Existing requests continue processing
4. Server waits up to 30 seconds for requests to complete
5. Logs progress every 5 seconds
6. After timeout or completion, shutdown proceeds
