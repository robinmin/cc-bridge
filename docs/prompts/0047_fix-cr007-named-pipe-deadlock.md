---
name: fix-cr007-named-pipe-deadlock
description: Fix potential deadlock in named pipe retry logic when switching from non-blocking to blocking mode
status: Done
created_at: 2026-01-29 00:00:00
updated_at: 2026-01-29 00:00:00
impl_progress:
  planning: completed
  design: completed
  implementation: completed
  review: completed
  testing: completed
severity: HIGH
category: Bug
---

## 0047. fix-cr007-named-pipe-deadlock

### Background

The named pipe implementation in `cc_bridge/core/named_pipe.py` has a potential deadlock condition. When a non-blocking write fails with ENXIO (no reader connected), the code retries with blocking mode. However, blocking mode can block forever if no reader ever connects.

**Location**: `cc_bridge/core/named_pipe.py` (lines 106-112)

**Problematic Pattern:**
```python
try:
    fd = os.open(pipe_path, os.O_WRONLY | os.O_NONBLOCK)
except OSError as e:
    if e.errno == errno.ENXIO:
        # No reader - retry with blocking (DANGER: blocks forever!)
        fd = os.open(pipe_path, os.O_WRONLY)  # No timeout!
```

**Impact:**
- Writer process can hang indefinitely
- No way to cancel or timeout the operation
- System resources tied up by blocked process
- Container/process lifecycle issues

### Requirements

**Functional Requirements:**
- Implement timeout for blocking pipe operations
- Provide cancellation mechanism
- Return meaningful error when reader unavailable

**Non-Functional Requirements:**
- Maximum wait time configurable (default: 30s)
- Clean resource cleanup on timeout/cancellation
- Clear logging of wait states

**Acceptance Criteria:**
- [x] Blocking pipe operations have configurable timeout
- [x] TimeoutError raised if reader doesn't connect in time
- [x] File descriptors properly closed on timeout
- [x] Async-compatible timeout mechanism
- [x] Tests verify timeout behavior
- [x] No resource leaks on timeout path

### Q&A

### Design

**Safe Pattern with Timeout:**
```python
import asyncio
import os
import errno

async def open_pipe_with_timeout(
    pipe_path: str,
    timeout: float = 30.0
) -> int:
    """Open pipe for writing with timeout."""
    loop = asyncio.get_running_loop()

    async def try_open():
        while True:
            try:
                # Try non-blocking first
                fd = await loop.run_in_executor(
                    None,
                    lambda: os.open(pipe_path, os.O_WRONLY | os.O_NONBLOCK)
                )
                return fd
            except OSError as e:
                if e.errno == errno.ENXIO:
                    # No reader yet, wait and retry
                    await asyncio.sleep(0.1)
                else:
                    raise

    try:
        return await asyncio.wait_for(try_open(), timeout=timeout)
    except asyncio.TimeoutError:
        raise TimeoutError(
            f"No reader connected to pipe {pipe_path} within {timeout}s"
        )
```

### Plan

1. [x] Add timeout parameter to pipe open functions
2. [x] Implement polling loop with asyncio.wait_for
3. [x] Remove blocking fallback pattern
4. [x] Add proper cleanup in exception handlers
5. [x] Update callers to handle TimeoutError
6. [x] Add integration tests for timeout scenarios

### Artifacts

| Type | Path | Generated By | Date |
|------|------|--------------|------|
| Deadlock Fix | cc_bridge/core/named_pipe.py | rd2:super-coder | 2026-01-29 |

### References

- File: `cc_bridge/core/named_pipe.py`
- Python FIFO: https://docs.python.org/3/library/os.html#os.mkfifo

### Implementation Details

**Before (Deadlock Risk):**
```python
except OSError as e:
    if e.errno == errno.ENXIO:
        # No reader - retry with blocking (DANGER: blocks forever!)
        fd = os.open(self.input_pipe_path, os.O_WRONLY)
```

**After (Safe with Timeout):**
```python
async def try_open_and_write() -> None:
    start_time = loop.time()

    while True:
        try:
            fd = await loop.run_in_executor(
                None,
                lambda: os.open(self.input_pipe_path, os.O_WRONLY | os.O_NONBLOCK)
            )
            # ... write and close ...
            return
        except OSError as e:
            elapsed = loop.time() - start_time
            if elapsed > timeout:
                raise asyncio.TimeoutError(
                    f"No reader connected to pipe {self.input_pipe_path} within {timeout}s"
                )
            if e.errno == errno.ENXIO:
                await asyncio.sleep(0.1)
```

**Key Changes:**
1. Added `timeout` parameter to `write_command()` (default: 30s)
2. Implemented async polling loop using `asyncio.run_in_executor`
3. Removed dangerous blocking fallback pattern
4. Proper timeout handling with `asyncio.TimeoutError`
5. File descriptors properly closed via try/finally
6. Updated `send_and_receive()` to pass timeout parameter
